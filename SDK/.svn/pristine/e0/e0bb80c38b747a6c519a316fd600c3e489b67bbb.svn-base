/// -------------------------------------------------------------------------------------------
/// FileName：CITFileProcess.cs
/// 说    明：CIT文件相关操作
/// Version ：1.0
/// Date    ：2017/5/26
/// Author  ：CaoKai
/// -------------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace CitFileSDK
{
    /// <summary>
    /// CIT文件相关操作类
    /// </summary>
    public partial class CITFileProcess
    {

        #region ChannelDefinition

        #region ChannelDefinition 读取

        /// <summary>
        /// 获取所有channel的定义信息
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <returns>通道定义集合</returns>
        public List<ChannelDefinition> GetChannelDefinitionList(string citFile)
        {
            // 这里要注意：通道id如果直接从文件中获取，可能得到错误的值（创建cit文件时可能写入错误的值）
            // 所以，channel id需要程序单独计算，计数从0开始，0，1，2，3，4......
            using (FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            {
                using (BinaryReader br = new BinaryReader(fs, Encoding.Default))
                {
                    br.BaseStream.Position = 0;

                    FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                    byte[] bChannelData = br.ReadBytes(fi.iChannelNumber * DataOffset.DataChannelLength);
                    List<ChannelDefinition> cdList = new List<ChannelDefinition>();
                    for (int i = 0; i < fi.iChannelNumber * DataOffset.DataChannelLength; i += DataOffset.DataChannelLength)
                    {
                        ChannelDefinition cd = GetChannelInfo(bChannelData, i);
                        if (i == DataOffset.DataChannelLength)
                        {
                            cd.fScale = 4;
                        }
                        cdList.Add(cd);
                    }

                    return cdList;
                }
            }
        }

        /// <summary>
        /// 获取通道的字节数组
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <returns>获取通道字节数组</returns>
        public byte[] GetChannelDefinitionsBytes(string citFile)
        {
            using (FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            {
                using (BinaryReader br = new BinaryReader(fs, Encoding.Default))
                {
                    br.BaseStream.Position = 0;

                    FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                    byte[] bChannelData = br.ReadBytes(fi.iChannelNumber * DataOffset.DataChannelLength);
                    return bChannelData;
                }
            }
        }

        #endregion

        #region ChannelDefinition 写入

        /// <summary>
        /// 将通道的字节数组写入文件中
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="bytes">字节数组</param>
        /// <returns>是否写入成功 true：成功；false：失败</returns>
        public bool WriteChannelDefinitionsBytes(string citFile, byte[] bytes)
        {
            try
            {
                using (FileStream fsWrite = new FileStream(citFile, FileMode.OpenOrCreate, FileAccess.Write, FileShare.ReadWrite))
                {
                    using (BinaryWriter bw = new BinaryWriter(fsWrite, Encoding.UTF8))
                    {
                        bw.BaseStream.Position = DataOffset.DataHeadLength;
                        bw.Write(bytes);
                        bw.Close();
                    }
                    fsWrite.Close();
                }
                return true;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
            }
        }

        /// <summary>
        /// 将通道定义信息写入文件中
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="channelList"></param>
        /// <returns></returns>
        public bool WriteChannelDefinitionList(string citFile, List<ChannelDefinition> channelList)
        {
            try
            {
                using (FileStream fsWrite = new FileStream(citFile, FileMode.OpenOrCreate, FileAccess.Write, FileShare.ReadWrite))
                {
                    using (BinaryWriter bw = new BinaryWriter(fsWrite, Encoding.UTF8))
                    {
                        bw.BaseStream.Position = DataOffset.DataHeadLength;
                        bw.Write(GetBytesFromChannelDataInfoList(channelList));
                        bw.Close();
                    }
                    fsWrite.Close();
                }
                return true;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
            }
        }

        #endregion

        #endregion


        #region 附加信息

        #region 获取附加信息

        /// <summary>
        /// 获取文件头补充信息
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <returns></returns>
        public byte[] GetExtraInfo(string citFile)
        {
            FileInformation fi;

            using (FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            {
                using (BinaryReader br = new BinaryReader(fs, Encoding.Default))
                {
                    fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));
                    br.BaseStream.Position = DataOffset.DataHeadLength + fi.iChannelNumber * DataOffset.DataChannelLength;
                    byte[] extraByte = br.ReadBytes(BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));
                    return extraByte;
                }
            }
        }

        #endregion

        #region 写入附加信息

        /// <summary>
        /// 向文件中写入文件头补充信息
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="info">补充信息</param>
        /// <returns></returns>
        public bool WriteExtraInfo(string citFile,byte[] info)
        {
            try
            {
                using (FileStream fs = new FileStream(citFile, FileMode.OpenOrCreate, FileAccess.Write, FileShare.ReadWrite))
                {
                    using (BinaryWriter bw = new BinaryWriter(fs, Encoding.Default))
                    {
                        FileInformation fi = GetFileInformation(citFile);
                        bw.BaseStream.Position = DataOffset.DataHeadLength + fi.iChannelNumber * DataOffset.DataChannelLength;

                        bw.Write((Byte)(info.Length));
                        bw.Write(info);
                        if (info.Length < 4)
                        {
                            for (int i = 0; i < (4 - info.Length); i++)
                            {
                                bw.Write((byte)0);
                            }
                        }
                        bw.Close();
                    }
                    fs.Close();
                }
                return true;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
            }
        }

        /// <summary>
        /// 向文件中写入文件头补充信息
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="info">补充信息</param>
        /// <returns></returns>
        public bool WriteExtraInfo(string citFile, string info)
        {
            try
            {
                using (FileStream fs = new FileStream(citFile, FileMode.OpenOrCreate, FileAccess.Write, FileShare.ReadWrite))
                {
                    using (BinaryWriter bw = new BinaryWriter(fs, Encoding.Default))
                    {
                        FileInformation fi = GetFileInformation(citFile);
                        bw.BaseStream.Position = DataOffset.DataHeadLength + fi.iChannelNumber * DataOffset.DataChannelLength;

                        byte[] tmpBytes = UnicodeEncoding.Default.GetBytes(info);
                        bw.Write((Byte)(tmpBytes.Length));
                        bw.Write(tmpBytes);
                        if (tmpBytes.Length < 4)
                        {
                            for (int i = 0; i < (4 - tmpBytes.Length); i++)
                            {
                                bw.Write((byte)0);
                            }
                        }
                        bw.Close();
                    }
                    fs.Close();
                }
                return true;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
            }
        }

        #endregion

        #endregion


        #region 获取通道数据

        #region 里程信息

        /// <summary>
        /// 得到文件中的所有里程信息
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <returns>所有公里信息</returns>
        public List<Milestone> GetAllMileStone(string citFile)
        {
            List<Milestone> listMilestone = new List<Milestone>();

            FileInformation fi = GetFileInformation(citFile);
            FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            BinaryReader br = new BinaryReader(fs, Encoding.Default);
            br.BaseStream.Position = FileDataOffset.GetSamplePointStartOffset(fi.iChannelNumber, BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));
            
            int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
            byte[] b = new byte[iChannelNumberSize];
            long iArray = (br.BaseStream.Length - br.BaseStream.Position) / iChannelNumberSize;

            for (int i = 0; i < iArray; i++)
            {
                Milestone milestone = new Milestone();
                milestone.mFilePosition = br.BaseStream.Position;

                b = br.ReadBytes(iChannelNumberSize);
                if (Encryption.IsEncryption(fi.sDataVersion))
                {
                    b = Encryption.Translate(b);
                }

                short km = BitConverter.ToInt16(b, 0);
                short m = BitConverter.ToInt16(b, 2);

                milestone.mKm = km;
                milestone.mMeter = m;

                listMilestone.Add(milestone);
            }

            br.Close();
            fs.Close();

            return listMilestone;
        }

        /// <summary>
        /// 找到第一个采样点，读取其里程信息
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <returns>公里信息</returns>
        public Milestone GetStartMilestone(string citFile)
        {
            FileInformation fi = GetFileInformation(citFile);

            FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            BinaryReader br = new BinaryReader(fs, Encoding.Default);
            br.BaseStream.Position = FileDataOffset.GetSamplePointStartOffset(fi.iChannelNumber, BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));

            int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
            byte[] b = new byte[iChannelNumberSize];

            Milestone milestone = new Milestone();
            milestone.mFilePosition = br.BaseStream.Position;

            b = br.ReadBytes(iChannelNumberSize);
            if (Encryption.IsEncryption(fi.sDataVersion))
            {
                b = Encryption.Translate(b);
            }

            short km = BitConverter.ToInt16(b, 0);
            short m = BitConverter.ToInt16(b, 2);

            milestone.mKm = km;
            milestone.mMeter = m;
            
            br.Close();
            fs.Close();

            return milestone;
        }
        
        /// <summary>
        /// 找到最后一个采样点，读取其里程信息
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <returns>公里信息</returns>
        public Milestone GetEndMilestone(string citFile)
        {
            FileInformation fi = GetFileInformation(citFile);

            FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            BinaryReader br = new BinaryReader(fs, Encoding.Default);
            br.BaseStream.Position = FileDataOffset.GetSamplePointStartOffset(fi.iChannelNumber, BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));

            int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
            byte[] b = new byte[iChannelNumberSize];
            long iArray = (br.BaseStream.Length - br.BaseStream.Position) / iChannelNumberSize;

            Milestone milestone = new Milestone();

            if (iArray > 1)
            {
                int num = (int)(iArray - 1);
                br.BaseStream.Position += iChannelNumberSize * num;

                milestone.mFilePosition = br.BaseStream.Position;

                b = br.ReadBytes(iChannelNumberSize);
                if (Encryption.IsEncryption(fi.sDataVersion))
                {
                    b = Encryption.Translate(b);
                }

                short km = BitConverter.ToInt16(b, 0);
                short m = BitConverter.ToInt16(b, 2);

                milestone.mKm = km;
                milestone.mMeter = m;
            }

            br.Close();
            fs.Close();

            return milestone;
        }

        #endregion


        #region 获取指定通道的通道数据

        /// <summary>
        /// 获取指定通道的通道数据
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="channelId">通道号</param>
        /// <param name="startFilePos">开始位置</param>
        /// <param name="endFilePos">结束位置</param>
        /// <returns>通道数据</returns>
        private double[] GetOneChannelDataInRange(string citFile, int channelId, long startFilePos, long endFilePos)
        {
            try
            {
                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                List<ChannelDefinition> cdList = GetChannelDefinitionList(citFile);

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];

                br.BaseStream.Position = startFilePos;

                long iArray = (endFilePos - br.BaseStream.Position) / iChannelNumberSize;
                double[] fReturnArray = new double[iArray];
                for (int i = 0; i < iArray; i++)
                {
                    b = br.ReadBytes(iChannelNumberSize);
                    if (Encryption.IsEncryption(fi.sDataVersion))
                    {
                        b = Encryption.Translate(b);
                    }

                    double fGL = (BitConverter.ToInt16(b, (channelId - 1) * 2) / cdList[channelId - 1].fScale + cdList[channelId - 1].fOffset);

                    fReturnArray[i] = fGL;
                }
                br.Close();
                fs.Close();

                return fReturnArray;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        
        /// <summary>
        /// 获取指定通道的通道数据(从开始位置开始，获取指定个数的采样点)
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="channelId">通道号</param>
        /// <param name="startFilePos">开始位置</param>
        /// <param name="sampleNum">采样点个数</param>
        /// <returns>通道数据</returns>
        public double[] GetOneChannelDataInRange(string citFile, int channelId, long startFilePos, int sampleNum)
        {
            try
            {
                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));
                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);

                long endFilePos = sampleNum * iChannelNumberSize;

                br.Close();
                fs.Close();

                double[] fReturnArray = GetOneChannelDataInRange(citFile, channelId, startFilePos, endFilePos);

                return fReturnArray;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        /// <summary>
        /// 根据开始里程和采样点个数获取指定通道的通道数据
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="channelId">通道号</param>
        /// <param name="startMilestone">开始里程</param>
        /// <param name="sampleNum">采样点个数</param>
        /// <returns>通道数据</returns>
        public double[] GetOneChannelDataInRange(string citFile, int channelId, float startMilestone, int sampleNum)
        {
            try
            {
                List<ChannelDefinition> m_dcil = new List<ChannelDefinition>();

                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                m_dcil = GetChannelDefinitionList(citFile);

                br.BaseStream.Position = FileDataOffset.GetSamplePointStartOffset(fi.iChannelNumber, BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];
                long iArray = (br.BaseStream.Length - br.BaseStream.Position) / iChannelNumberSize;
                double[] fReturnArray = new double[iArray];

                List<double> listValue = new List<double>();

                for (int i = 0; i < iArray; i++)
                {
                    b = br.ReadBytes(iChannelNumberSize);
                    if (Encryption.IsEncryption(fi.sDataVersion))
                    {
                        b = Encryption.Translate(b);
                    }

                    short km = BitConverter.ToInt16(b, 0);

                    short m = BitConverter.ToInt16(b, 2);
                    float fGLMile = km + (float)m / fi.iSmaleRate / 1000;//单位为公里

                    //增里程的情况
                    if (fi.iKmInc==0 && fGLMile >= startMilestone)
                    {
                        double fGL = (BitConverter.ToInt16(b, (channelId - 1) * 2) / m_dcil[channelId - 1].fScale + m_dcil[channelId - 1].fOffset);

                        listValue.Add(fGL);
                    }
                    //减里程的情况
                    if (fi.iKmInc == 1 && fGLMile <= startMilestone)
                    {
                        double fGL = (BitConverter.ToInt16(b, (channelId - 1) * 2) / m_dcil[channelId - 1].fScale + m_dcil[channelId - 1].fOffset);

                        listValue.Add(fGL);
                    }
                    if (listValue.Count == sampleNum)
                    {
                        break;
                    }
                }

                br.Close();
                fs.Close();

                double[] result = listValue.ToArray();
                return result;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        /// <summary>
        /// 获取指定通道的里程范围内的通道数据
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="channelId">通道号</param>
        /// <param name="startMilestone">开始里程</param>
        /// <param name="endMilestone">结束里程</param>
        /// <returns>通道数据</returns>
        public double[] GetOneChannelDataInRangeByMilestone(string citFile, int channelId, float startMilestone, int endMilestone)
        {
            try
            {
                List<ChannelDefinition> m_dcil = new List<ChannelDefinition>();

                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                m_dcil = GetChannelDefinitionList(citFile);

                br.BaseStream.Position = FileDataOffset.GetSamplePointStartOffset(fi.iChannelNumber, BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];
                long iArray = (br.BaseStream.Length - br.BaseStream.Position) / iChannelNumberSize;
                double[] fReturnArray = new double[iArray];

                List<double> listValue = new List<double>();

                for (int i = 0; i < iArray; i++)
                {
                    b = br.ReadBytes(iChannelNumberSize);
                    if (Encryption.IsEncryption(fi.sDataVersion))
                    {
                        b = Encryption.Translate(b);
                    }

                    short km = BitConverter.ToInt16(b, 0);

                    short m = BitConverter.ToInt16(b, 2);
                    float fGLMile = km + (float)m / fi.iSmaleRate / 1000;//单位为公里

                    if (fGLMile >= startMilestone && fGLMile < endMilestone)
                    {
                        double fGL = (BitConverter.ToInt16(b, (channelId - 1) * 2) / m_dcil[channelId - 1].fScale + m_dcil[channelId - 1].fOffset);

                        listValue.Add(fGL);
                    }
                }

                br.Close();
                fs.Close();

                double[] result = listValue.ToArray();
                return result;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        #endregion


        #region 获取所有通道的数据

        /// <summary>
        /// 获取所有通道的数据
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="startFilePos">开始位置</param>
        /// <param name="endFilePos">结束位置</param>
        /// <returns>所有通道数据</returns>
        private List<double[]> GetAllChannelDataInRange(string citFile ,long startFilePos, long endFilePos)
        {
            try
            {
                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                List<ChannelDefinition> cdList = GetChannelDefinitionList(citFile);

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];

                br.BaseStream.Position = startFilePos;

                long iArray = (endFilePos - br.BaseStream.Position) / iChannelNumberSize;
                double[] fReturnArray = new double[iArray];


                List<double[]> allList = new List<double[]>();
                for (int i = 0; i < fi.iChannelNumber; i++)
                {
                    double[] array = new double[iArray];
                    allList.Add(array);
                }

                for (int i = 0; i < iArray; i++)
                {
                    b = br.ReadBytes(iChannelNumberSize);

                    fi.iRunDir = BitConverter.ToInt32(b, DataHeadOffset.RunDir);


                    if (Encryption.IsEncryption(fi.sDataVersion))
                    {
                        b = Encryption.Translate(b);
                    }

                    for (int channelId = 1; channelId < fi.iChannelNumber + 1; channelId++)
                    {
                        double fGL = (BitConverter.ToInt16(b, (channelId - 1) * 2) / cdList[channelId - 1].fScale + cdList[channelId - 1].fOffset);

                        allList[channelId - 1][i] = fGL;
                    }
                }
                br.Close();
                fs.Close();

                return allList;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        
        /// <summary>
        /// 获取所有通道数据
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="startFilePos">开始位置</param>
        /// <param name="sampleNum">采样点个数</param>
        /// <returns>所有通道数据</returns>
        public List<double[]> GetAllChannelDataInRange(string citFile, long startFilePos, int sampleNum)
        {
            try
            {
                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                List<ChannelDefinition> cdList = GetChannelDefinitionList(citFile);

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];

                br.BaseStream.Position = startFilePos;
                long endFilePos = sampleNum * iChannelNumberSize;

                br.Close();
                fs.Close();

                var allList = GetAllChannelDataInRange(citFile, startFilePos, endFilePos);

                return allList;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        /// <summary>
        /// 根据开始里程和采样点个数获取所有通道数据
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="startMilestone">开始里程</param>
        /// <param name="sampleNum">采样点个数</param>
        /// <returns>所有通道数据</returns>
        public List<double[]> GetAllChannelDataInRange(string citFile, float startMilestone, int sampleNum)
        {
            try
            {
                List<ChannelDefinition> cdList = new List<ChannelDefinition>();

                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                cdList = GetChannelDefinitionList(citFile);

                br.BaseStream.Position = FileDataOffset.GetSamplePointStartOffset(fi.iChannelNumber, BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];
                long iArray = (br.BaseStream.Length - br.BaseStream.Position) / iChannelNumberSize;

                List<List<double>> listAll = new List<List<double>>();

                for (int i = 0; i < iArray; i++)
                {
                    b = br.ReadBytes(iChannelNumberSize);
                    if (Encryption.IsEncryption(fi.sDataVersion))
                    {
                        b = Encryption.Translate(b);
                    }

                    short km = BitConverter.ToInt16(b, 0);
                    short m = BitConverter.ToInt16(b, 2);
                    float fGLMile = km + (float)m / fi.iSmaleRate / 1000;//单位为公里

                    //增里程的情况
                    if (fi.iKmInc == 0 && fGLMile >= startMilestone)
                    {
                        for (int channelId = 1; channelId < fi.iChannelNumber + 1; channelId++)
                        {
                            double fGL = (BitConverter.ToInt16(b, (channelId - 1) * 2) / cdList[channelId - 1].fScale + cdList[channelId - 1].fOffset);

                            listAll[channelId - 1].Add(fGL);

                        }
                    }
                    //减里程的情况
                    if (fi.iKmInc == 1 && fGLMile <= startMilestone)
                    {
                        for (int channelId = 1; channelId < fi.iChannelNumber + 1; channelId++)
                        {
                            double fGL = (BitConverter.ToInt16(b, (channelId - 1) * 2) / cdList[channelId - 1].fScale + cdList[channelId - 1].fOffset);

                            listAll[channelId - 1].Add(fGL);
                        }
                    }

                    if (listAll[0].Count == sampleNum)
                    {
                        break;
                    }
                }

                List<double[]> allList = new List<double[]>();

                for (int i = 0; i < listAll.Count; i++)
                {
                    allList.Add(listAll[i].ToArray());
                }

                br.Close();
                fs.Close();

                return allList;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        /// <summary>
        /// 获取指定里程范围内的全部通道数据
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="startMilestone">开始里程</param>
        /// <param name="endMilestone">结束里程</param>
        /// <returns>所有通道数据</returns>
        public List<double[]> GetAllChannelDataInRangeByMilestone(string citFile, float startMilestone, int endMilestone)
        {
            try
            {
                List<ChannelDefinition> cdList = new List<ChannelDefinition>();

                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                cdList = GetChannelDefinitionList(citFile);

                br.BaseStream.Position = FileDataOffset.GetSamplePointStartOffset(fi.iChannelNumber, BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];
                long iArray = (br.BaseStream.Length - br.BaseStream.Position) / iChannelNumberSize;
                double[] fReturnArray = new double[iArray];

                List<double> listValue = new List<double>();

                List<double[]> allList = new List<double[]>();
                for (int i = 0; i < fi.iChannelNumber; i++)
                {
                    double[] array = new double[iArray];
                    allList.Add(array);
                }

                for (int i = 0; i < iArray; i++)
                {
                    b = br.ReadBytes(iChannelNumberSize);
                    if (Encryption.IsEncryption(fi.sDataVersion))
                    {
                        b = Encryption.Translate(b);
                    }

                    short km = BitConverter.ToInt16(b, 0);
                    short m = BitConverter.ToInt16(b, 2);
                    float fGLMile = km + (float)m / fi.iSmaleRate / 1000;//单位为公里

                    if (fGLMile >= startMilestone && fGLMile < endMilestone)
                    {
                        for (int channelId = 1; channelId < fi.iChannelNumber + 1; channelId++)
                        {
                            double fGL = (BitConverter.ToInt16(b, (channelId - 1) * 2) / cdList[channelId - 1].fScale + cdList[channelId - 1].fOffset);

                            allList[channelId - 1][i] = fGL;
                        }
                    }
                }

                br.Close();
                fs.Close();

                return allList;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        #endregion


        #region 获取通道的字节数组

        /// <summary>
        /// 根据开始位置、结束位置获取所有通道的字节数组
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="startFilePos">开始位置</param>
        /// <param name="endFilePos">结束位置</param>
        /// <returns>字节数组</returns>
        private byte[] GetChannelDataBytesInRange(string citFile, long startFilePos, long endFilePos)
        {
            try
            {
                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                List<ChannelDefinition> cdList = GetChannelDefinitionList(citFile);

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];

                br.BaseStream.Position = startFilePos;

                byte[] bytes = br.ReadBytes(Convert.ToInt32(endFilePos - startFilePos));

                br.Close();
                fs.Close();

                return bytes;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }
        
        /// <summary>
        /// 根据开始位置以及采样点个数获取所有通道的字节数组
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="startFilePos">开始位置</param>
        /// <param name="sampleNum">采样点个数</param>
        /// <returns>字节数组</returns>
        public byte[] GetChannelDataBytesInRange(string citFile, long startFilePos, int sampleNum)
        {
            try
            {
                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                List<ChannelDefinition> cdList = GetChannelDefinitionList(citFile);

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];

                br.BaseStream.Position = startFilePos;

                byte[] bytes = br.ReadBytes(sampleNum * iChannelNumberSize);

                br.Close();
                fs.Close();

                return bytes;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        /// <summary>
        /// 根据开始里程和采样点数获取所有通道的字节数组
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="startMilestone">开始里程</param>
        /// <param name="sampleNum">采样点个数</param>
        /// <returns>字节数组</returns>
        public byte[] GetChannelDataBytesInRange(string citFile, float startMilestone, int sampleNum)
        {
            try
            {
                List<ChannelDefinition> cdList = new List<ChannelDefinition>();

                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                cdList = GetChannelDefinitionList(citFile);

                br.BaseStream.Position = FileDataOffset.GetSamplePointStartOffset(fi.iChannelNumber, BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];
                long iArray = (br.BaseStream.Length - br.BaseStream.Position) / iChannelNumberSize;

                long startPosition = br.BaseStream.Position;

                for (int i = 0; i < iArray; i++)
                {
                    b = br.ReadBytes(iChannelNumberSize);
                    if (Encryption.IsEncryption(fi.sDataVersion))
                    {
                        b = Encryption.Translate(b);
                    }

                    short km = BitConverter.ToInt16(b, 0);
                    short m = BitConverter.ToInt16(b, 2);
                    float fGLMile = km + (float)m / fi.iSmaleRate / 1000;//单位为公里

                    //增里程的情况
                    if (fi.iKmInc == 0 && fGLMile >= startMilestone)
                    {
                        startPosition = br.BaseStream.Position - iChannelNumberSize;
                        break;
                    }
                    //减里程的情况
                    if (fi.iKmInc == 1 && fGLMile <= startMilestone)
                    {
                        startPosition = br.BaseStream.Position - iChannelNumberSize;
                        break;
                    }
                }

                long endPosition = startPosition + sampleNum * iChannelNumberSize;

                br.BaseStream.Position = startPosition;

                byte[] bytes = br.ReadBytes(sampleNum * iChannelNumberSize);

                return bytes;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        /// <summary>
        /// 根据开始里程、结束里程获取所有通道的字节数组
        /// </summary>
        /// <param name="citFile">cit文件路径</param>
        /// <param name="startMilestone">开始里程</param>
        /// <param name="endMilestone">结束里程</param>
        /// <returns>字节数组</returns>
        public byte[] GetChannelDataBytesInRangeByMilestone(string citFile, float startMilestone, int endMilestone)
        {
            try
            {
                List<ChannelDefinition> cdList = new List<ChannelDefinition>();

                FileStream fs = new FileStream(citFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                BinaryReader br = new BinaryReader(fs, Encoding.Default);
                br.BaseStream.Position = 0;

                FileInformation fi = GetDataInfoHead(br.ReadBytes(DataOffset.DataHeadLength));

                cdList = GetChannelDefinitionList(citFile);

                br.BaseStream.Position = FileDataOffset.GetSamplePointStartOffset(fi.iChannelNumber, BitConverter.ToInt32(br.ReadBytes(DataOffset.ExtraLength), 0));

                int iChannelNumberSize = BytesOfOneSamplePoint(fi.iChannelNumber);
                byte[] b = new byte[iChannelNumberSize];
                long iArray = (br.BaseStream.Length - br.BaseStream.Position) / iChannelNumberSize;

                long startPosition = br.BaseStream.Position;
                long endPosition = 0;

                bool startFirst=false;
                bool endFirst=false;
                for (int i = 0; i < iArray; i++)
                {
                    b = br.ReadBytes(iChannelNumberSize);
                    if (Encryption.IsEncryption(fi.sDataVersion))
                    {
                        b = Encryption.Translate(b);
                    }

                    short km = BitConverter.ToInt16(b, 0);
                    short m = BitConverter.ToInt16(b, 2);
                    float fGLMile = km + (float)m / fi.iSmaleRate / 1000;//单位为公里

                    //增里程的情况
                    if (fi.iKmInc == 0 && fGLMile >= startMilestone)
                    {
                        if(!startFirst)
                        {
                            startPosition = br.BaseStream.Position - iChannelNumberSize;
                            startFirst=true;
                        }
                    }
                    if (fi.iKmInc == 0 && fGLMile > endMilestone)
                    {
                        if (!endFirst)
                        {
                            endPosition = br.BaseStream.Position - iChannelNumberSize;
                            endFirst = true;
                        }
                    }
                    //减里程的情况
                    if (fi.iKmInc == 1 && fGLMile <= startMilestone)
                    {
                        if (!startFirst)
                        {
                            startPosition = br.BaseStream.Position - iChannelNumberSize;
                            startFirst = true;
                        }
                    }
                    if (fi.iKmInc == 1 && fGLMile < endMilestone)
                    {
                        if (!endFirst)
                        {
                            endPosition = br.BaseStream.Position - iChannelNumberSize;
                            endFirst = true;
                        }
                    }
                }

                br.BaseStream.Position = startPosition;

                byte[] bytes = br.ReadBytes(Convert.ToInt32(endPosition - startPosition));

                return bytes;
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message, ex);
            }
        }

        #endregion

        #endregion

    }
}
